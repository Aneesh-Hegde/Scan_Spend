import { useState, useEffect, useCallback } from 'react';
import { Metadata } from 'grpc-web';
import { BalanceServiceClient } from '../grpc_schema/BalanceServiceClientPb';
import { GetIncomeRequest, GetIncomeResponse, AddIncomeSourceRequest, UpdateIncomeRequest } from '../grpc_schema/balance_pb';
import incomeService from '../services/incomeService'; // Centralized gRPC calls

// Define the Income interface (ensure it's consistent across files)
interface Income {
  id: number;
  source: string;
  amountDescription: string;
  amount: number;
  date: string;
}

// Consider moving incomeClient instantiation to incomeService for better isolation
const incomeClient = new BalanceServiceClient("http://localhost:8080");

const useIncomeData = (token: string | null, refreshToken: string | null) => {
  const [incomes, setIncomes] = useState<Income[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchIncomes = useCallback(async () => {
    if (!token || !refreshToken) {
      // Don't fetch if tokens are not yet available
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      const requestMetadata: Metadata = { authentication: `Bearer ${token}`, refresh_token: refreshToken };

      // Use the centralized service function
      const fetchedIncomes = await incomeService.getIncomes(incomeClient, requestMetadata);
      setIncomes(fetchedIncomes);
    } catch (err: any) {
      setError("Failed to fetch incomes: " + err.message);
      console.error("Fetch Incomes Error:", err);
    } finally {
      setLoading(false);
    }
  }, [token, refreshToken]); // Re-run if tokens change

  useEffect(() => {
    fetchIncomes();
  }, [fetchIncomes]);

  const addIncome = async (newIncomeData: Omit<Income, 'id'>) => {
    if (!token || !refreshToken) {
      setError("Authentication required to add income.");
      return;
    }
    try {
      const requestMetadata: Metadata = { authentication: `Bearer ${token}`, refresh_token: refreshToken };
      // Assuming ID is generated by backend or a temporary client-side ID
      const tempId = Math.max(0, ...incomes.map(inc => inc.id)) + 1; // Simple temp ID
      const incomeToAdd = { ...newIncomeData, id: tempId };

      await incomeService.addIncome(incomeClient, requestMetadata, incomeToAdd);
      setIncomes(prev => [...prev, incomeToAdd]); // Add immediately for optimistic update
      // Optionally re-fetch after successful add to get server-generated ID
      // fetchIncomes();
    } catch (err: any) {
      setError("Failed to add income: " + err.message);
      console.error("Add Income Error:", err);
    }
  };

  const updateIncome = async (editedIncomeData: Income) => {
    if (!token || !refreshToken) {
      setError("Authentication required to update income.");
      return;
    }
    try {
      const requestMetadata: Metadata = { authentication: `Bearer ${token}`, refresh_token: refreshToken };
      await incomeService.updateIncome(incomeClient, requestMetadata, editedIncomeData);
      setIncomes(prev => prev.map(inc => (inc.id === editedIncomeData.id ? editedIncomeData : inc)));
    } catch (err: any) {
      setError("Failed to update income: " + err.message);
      console.error("Update Income Error:", err);
    }
  };

  return { incomes, loading, error, fetchIncomes, addIncome, updateIncome };
};

export default useIncomeData;
